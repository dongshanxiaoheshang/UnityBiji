 5，我们创建一个类的对象后，需要给这个对象的属性赋值，我们称这个该过程叫做对象的初始化



6.静态和非静态的区别：
1）调用非静态方法（实例），对象名.实例成员；
     调用静态方法，类名.静态成员名；
    静态成员需要类名去调用，非静态成员（实例成员）需要用对象去调用；
    静态函数中只能访问静态成员，不能访问实例成员；
    实例（非静态）函数中，技能访问实例成员，又能能访问静态成员；
   静态类中只允许存在静态成员
使用：如果你想让你的类变成“工具类”，可以考虑使用静态类//使用频繁
2】静态类在整个项目中，资源共享；




7，，构造函数
作用：帮组我们初始化对象（给对象的每个属性依次赋值）
构造函数是一个特殊的方法
1） 构造函数没有返回值，连void也没有；
2）构造函数的名称必须和类名一致；

创建对象的时候调用构造函数；
构造函数是可以又重载的，就是名称一致；

8，，，，new 关键字
Person zsPerson=new Peerson()
new帮我们做三件事
1），在内存中开辟一块空间
2），在开辟的空间中创建对象
3），调用对象的构造函数进行哦初始化

this关键字
1）代表当前类的对象
2）在类中显示的调用本类的构造函数：this



复习（类）：：字段，属性，方法 构造函数
字段：存储数据
属性：保护字段，对字段的取值和设值进行限定
方法：描述对象的行为
构造函数：初始化对象（给对象的每个属性一次赋值）
类中的成员不加访问修饰符，都默认是private（只能在当前类的项目中访问）；

构造函数：1  没有返回值，连void也没有
                 2  构造函数的名称跟类名一样











                            命名空间

可以认为类是属于命名空间的
如果在当前项目中没有类的命名空间，需要我们手动的导入这个类所在的命名空间11
1），用鼠标去点
2），alt+shift+F10；
3）记住命名空间，自己手打


在一个项目中引用另一个项目的类
1）添加引用
2）引用命名空间


3，值类型和引用类型
区别：1，值类型和引用类型在内存上存储的地方不一样
2，在传递值类型和传递引用类型的时候，传递的方式不同
值类型我们称为值传递，引用类型我们称为引用传递；

值类型：int double  bool   char   decimal(金钱)   struct（结构）  enum（枚举）; {存储在内存的栈中}
引用类型：string  自定义类  数组；{存储在内存的堆中}  

字符串
1)字符串的不可变性    当你重新给一个字符串赋值的时候，老值并没有消失，而是重新开辟一个储存空间给新值

2）我们可以讲字符串看做是char类型的一个只读数组。所以我们可以通过下标去访问字符串的某一个元素

string s="abcdefg"//char[]  cha=s.ToCharArray();    将字符串转换成char类型的数组
                              //chs[0]=b;    
console.writeline(s[0]);

//neww  string(char[]  chs);   能够将char数组转换为字符串 


字符串提供的各种方法：
1）Length：获得当前字符串中的个数
2）ToUpp（）：//将字符串中的小写全部转换为大写
3）ToLower();   //将字符串中的小写全部转换为小写；
4）Equals（字符串名称,StringComparison.OrdinalIgnoreCase）；比较两个字符串，可以忽略大小写l；
5）Split():   分割字符串 ,返回字符串类型的数组；
6）Substring();  截取字符串，在截取的时候包含要截取的那个位置；
7）Indexof（）； 判断某个字符串在字符串中第一次出现的位置，如果没有，就返回-1；
8）LastIndexof();    判断某个字符串在字符串中最后一次出现的位置，如果没有，就返回-1；
9）StartWith():   判断以。。。。。开始
10）Endwith（）；  判断以。。。结束；
11）Replace（）；；  将字符串中某个字符替换成新的字符串
12）Contains（）：；判断字符串中是否包含指定的字符串；
13）Trim（）；；去掉字符串中的空格；
14）TrimEnd（）；；去掉字符串中结尾的空格；
15）TrimStart（）；；去掉字符串中开始的空格；
16）string.IsNullOrEmpty（）：：判断一个字符串是否为null或者为空
17）string.jion（）：将数组安照  指定的字符串连接，返回一个字符串；





   













                                       继承    
我们可能会在一些类中，写一些重复的成员，我么们可以将这些成员单独的封装成一个类中，作为这些类的父类;
例子，继承中的 student teach drive 是子类 （派生类）          person是父类（基类）；

子类继承了父类的属性和方法，但是子类并没有继承父类的私有字段； 

子类有没有继承父类的构造函数？？？？
答：：子类并没有继承父类的构造函数，但是子类会默认的调用父类的无参构造函数，
创建父类对象，让子类可以使用父类中成员；
所以，如果在父类中重新写一个有参数的构造函数之后，那个无参的就被覆盖上了，
子类就调用不到了，所以子类会报错；
解决方法：
1） 在父类中重新写一个无参的构造函数
2）在子类中显示的调用父类的构造函数，使用关键字 ：base（）
继承的特性
1，继承的单根性：  一个子类只能有一个父类；
2，继承的传递性，drive既可以用student，也可以用person的；
person ；  
student：person；  
drive：student； 





new 关键字

1）创建对象
2）隐藏从父类哪里继承过来的同名成员。
隐藏的后果就是子类调用不到父类的成员。






1，，里氏转换
1）子类可以赋值给父类   如果有一个地方需要一个父类作为参数，我们可以个一个子类代替
2)   如果父类中装的是子类对象，那么可以将这个父类强转为子类对象


2，子类对象可以调用父类的成员，但父类对象永远都只能调用自己的成员。

3，
is ：表示类型转化，如果能够转换成功，则返回一个true 否则返回一个false；
as： 表示类型转化，如果转换成功则返回对应的对象，否则返回一个null。

4，protected
受保护的：可以在当前类的内部以及该类的子类中访问；

5，ArrayList集合的长度问题：
每次集合中实际包含的元素个数（count）超过了可以包含的元素个数（capcity）的时候，集合都会向内存中申请多开辟一倍的空间，保持集合的长度够用；


6，Hastable 键值对集合  
在键值对集合中，我们是根据键值找值的。
键值对对象[键]=值；
注意：：：：：：键值对集合中，键必须是唯一的，而值是可以重复的。

7，forfeach循环；  var  根据值推断类型；


编码：：将字符串以怎样的形式保存为二进制；
乱码：：就是你保存这个文件所采用的编码，跟你打开这个文件所采用的编码格式不一样。




装箱  拆箱
装箱：就是将值类型（int bool char decimal double enum struct）转换为引用类型（string 自定义类型 数组）；
拆箱：就是将引用类型转换为值类型；
看这两种类型是否发生了装箱或者拆箱，要看这两种类型是否存在继承关系；
         int n = 3;
    object c = n;//装箱，把值类型转换给引用类型；
         int ss = (int)c;//拆箱，把引用类型转换给值类型；


3，将创建文件流对象的过程写在using当中，会自动地帮助我们释放流所占用的资源；
fileStream*******是操纵字节的 
streamRead是操作字符的
            using(FileStream fsRead=new FileStream("c#.txt", FileMode.OpenOrCreate, FileAccess.Read))  //读入
              {（写入   write）
               byte[] sb = new byte[1024 * 1024 * 5];
                //本次读取实际读取到的字节
                int r=fsRead.Read(sb, 0, sb.Length);
                //将字节数组中的每个元素按照我们指定的编码格式指定为字符串
               string s= Encoding.Default.GetString(sb, 0, r);
                }
         using(FileStream fsRead=new FileStream("c#.txt", FileMode.OpenOrCreate, FileAccess.write) 
          string s="尽天涯贫血的"
           byte[] sb=string s= Encoding.Default.GetString(s);













                                     多态：：让一个对象能够表现多种的状态或类型；
实现多态的三种方法：
1，虚方法。
将父类的方法标记为虚方法，使用关键字 virtual（在void方法前面添加）这个给函数可以被子类重新写一遍。（在子类方法前加一个override）
。
2，抽象类
当父类中的方法不知道如何去实现的时候，可以考虑将父类写成抽象类，将方法写成抽象方法（abstract）
1）抽象成员必须标记abstract，并且不能有任何实现；
2）抽象陈冠成员必须在抽象类中；
3）抽象类不能被实例化；
4）子类继承抽象类后，必须把父类所有的抽象成员重写（除非子类也是一个抽象类，则可以不用重写）
5）抽象成员可以包含实例成员，并且抽象类的实例成员可以不被子类实现；
6）抽象成员的访问修饰符不能是private；
7）抽象类是有构造函数的，虽然不能被实例化；
8）如果父类的抽象方法中有参数，那么继承这个抽象父类的子类在重写父类方法时候必须传入对应的参数。如果抽象父类的抽象方法中有返回值，那么子类在重写这个抽象方法的时候，也必须传入返回值；

如果父类中的方法有默认的实现，并且父类需要被实例化，这个时候可以考虑将父类定义成一个普通类，用虚方法来实现；
如果父类中的方法没有默认实现，父类也不需要被实例化，则可以将该类定义为抽象类；

3，接口
关键字：interface   规范，能力
类不允许多继承，所以要用到接口才可以多继承
接口中的成员不允许添加访问修饰符；（名称一般以I开通要，able结尾，代表能力），，不允许写方法体；
publicinterface IFlyable
{
  void Fyy（）；
}

接口是一种规范。
只要在一个类中继承了一个接口，这个类必须实现这个接口的所有成员。
为了多态，接口不能被实例化。也就是说，接口不创建对象；
接口中的成员不能加访问修饰符，接口中的成员不能有任何实现，（光说不做，，只是定义了一组未实现的成员）
接口中只能由方法，属性，索引器，事件，不能有字段和构造函数。
接口与接口之间可以继承，并且可以多继承。
接口并不能去继承一个类，而类可以继承接口。（接口只能继承接口，而类既可以继承接口，也可以继承类）
实现接口的子类必须实现该接口的全部成员。
一个类可以同时继承一个类，并实现多个接口，如果一个子类同时继承父类A，并使想了接口IA，那么在语法上，A必须写在I前面
class MyClsaa ：A, IA()

显示接口的目的：解决方法重名问题。
显示实现：：void Iflyable.Fly（）{}
普通实现：：public void fly（）{}
什么时候显示的去实现接口：：：当继承的接口中的方法和参数一模一样的时候，要用显示的接口
当一个抽象类实现接口的时候，需要子类去实现接口。

c#中的访问修饰符
1）public ：公开的，公共的‘
2）private：私有的，只能在当前类的内部发个文
3)internal: 只能在当前项目中访问，在同一个项目中，internal和public权限一样；

能够修饰类的访问修饰符只有两个：public internal
可访问性不一致，子类的访问权限不能高于父类的访问权限，会暴漏父类成员。

部分类：
在class前加一个partial 可以命名几个相同名字的类名，而且类里的成员可以相互调用；

密封类：
子class面前加一个sealed 密封类不可以被继承，但是可以继承别人；



1 ，设计模式
设计这个项目的一种方式；


值类型在复制的时候，传递的是这个值本身；
引用类型在复制的时候，传递的是对这个对象的引用



序列化：就是将对象转化为二进制
反序列化：就是将二进制转化为对象
作用：传输数据。
传输数据的时候，发送方先把数据转化为二进制，传送过去，接收方再把二进制转化为数据接收；
序列化：（BinaryFormatter）  Serialize 序列化对象’
1）







MD5加密

创建对象后，要把传入的字符串转换为字节数组
返回字节数组
在转换为字符串。





1，winform应用程序是一种智能客户端技术，我们可以使用winform应用程序帮助我们获得信息，或者传输信息等。
2，属性
Nmae： 在后台要获得前台的控件对象，需要使用Nmae属性。
